\subsection{Адаптивная схема кластеризации основных групп графа (CGGC)}
\label{sub:cggc}

Для создания адаптивного алгоритма, работающего на графах любого размера, предлагается использовать алгоритм $SPSA$ при выборе начальных алгоритмов. Так же при построении промежуточного разбиения предлагается использовать не все разбиения, а только некоторое количество лучших. Более точно адаптивная схема описывается следующим образом:

\begin{enumerate}
	\item На вход подается граф $G$. Выбираются размер возмущения $d \in \mathbb{N}$, чувствительность к перепадам функций качества $\alpha > 0 \in \mathbb{R}$, количество шагов $l \in \mathbb{N}$, начальное приближение $\hat{k}_0 \in \mathbb{N}$, максимальная оценка $k_{max} > 1 \in \mathbb{N}$ и $r \in (0, 1]$ --- параметр, отвечающий за количество лучших начальных разбиений, учавствующих в создании промежуточного разбиения. Инициализируется счетчик $n \leftarrow 0$ и множество начальных разбиений $S \leftarrow \emptyset$
	\item Увеличивается счетчик $n \leftarrow n + 1$
	\item \label{item:es-k+} Вычисляются следующие два параметра $RG$:\\
	$k_n^{-} \leftarrow \max\{1,\;\hat{k}_{n - 1} - d\}$ и $k_n^{+} \leftarrow \min\{k_{max},\;\hat{k}_{n - 1} + d\}$
	\item Выделяются сообщества в графе $G$ алгоритмом $RG_k$ с параметром $k = k_n^{-}$, получившееся разбиение $P_n^{-}$ записывается в список $S$, его модулярность обозначается $Q_n^{-}$
	\item Выделяются сообщества в графе $G$ алгоритмом $RG_k$ с параметром $k = k_n^{+}$, получившееся разбиение $P_n^{+}$ записывается в список $S$, его модулярность обозначается $Q_n^{+}$
	\item Вычисляются функции качества:\\
	$y_n^{-} \leftarrow -\ln Q_n^{-}$ и $y_n^{+} \leftarrow -\ln Q_n^{+}$
	\item Вычисляется следующая оценка
	\begin{equation}\label{eq:acggc-centre}
		\hat{k}_n = \max \left\{1,\ \min \left\{k_{max},\ \left[\hat{k}_{n - 1} - \alpha \frac{y_n^{+} - y_n^{-}}{k_n^{+} - k_n^{-}}\right] \right\} \right\}
	\end{equation}
	\item Если $n \ne l$ --- осуществляется переход на второй пункт, иначе --- на следующий
	\item Из множества $S$ исключаются все разбиения на сообщества с модулярностью $Q \le (1 - r)Q_{best}$, где $Q_{best}$ --- модулярность лучшего разбиения в $S$.
	\item Создается промежуточное разбиение --- максимальное перекрытие разбиений из множества $S$
	\item Финальным алгоритмом выделяются сообщества на основе промежуточного разбиения
\end{enumerate}

Далее в работе описанная схема будет называться адаптивной схемой кластеризации основных групп графа и обозначаться $ACGGC$ (Adaptive Core Groups Graph Clustering).


\subsubsection*{Исследование работоспособности при разных параметрах}

$ACGGC$ имеет достаточно много параметров, однако подобранные на четырех графах значения параметров показали хорошие результаты на всех остальных тестовых графах. Однако даже при плохих параметрах результат будет хуже лишь на несколько процентов. Хорошим набором параметров будет, например, $d = 2,\;\alpha = 1000,\;l = 6,\;\hat{k}_0 = 5,\;k_{max} = 50,\;r = 0.05$.

\begin{table}[h!]
 	\caption{Модулярности разбиений, полученных \emph{ACGGC} с разными $k_{max}$ на тестовых графах}
 	\label{tab:acggc_kmax_q}
 	{\footnotesize
 	\begin{tabularx}{\textwidth}{XR{1.1cm}R{1.1cm}R{1.1cm}R{1.1cm}R{1.1cm}}\hline
 		$k_{max}$		& $+\infty$	& 50		& 20		& 10		& 6 		\\\hline
 		polbooks		& 0.527237	& 0.527237	& 0.527237	& 0.527082	& 0.526985	\\
 		adjnoun			& 0.299720	& 0.299690	& 0.299859	& 0.300141	& 0.299676	\\
 		football		& 0.603324	& 0.603324	& 0.604184	& 0.604266	& 0.604266	\\
 		jazz			& 0.444739	& 0.444739	& 0.444739	& 0.444739	& 0.444739	\\
 		celegans		& 0.439770	& 0.439368	& 0.439750	& 0.439460	& 0.439431	\\
 		email			& 0.573470	& 0.573416	& 0.573652	& 0.573756	& 0.573513	\\
 		netscience		& 0.953033	& 0.908130	& 0.842085	& 0.793289	& 0.768572	\\
 		cond-mat-2003	& 0.737611	& 0.743572	& 0.749595	& 0.749894	& 0.739200	\\\hline
 	\end{tabularx}
 	}
\end{table}

\begin{table}[h!]
 	\caption{Время работы \emph{ACGGC} при разных $k_{max}$ на тестовых графах}
 	\label{tab:acggc_kmax_t}
 	{\footnotesize
 	\begin{tabularx}{\textwidth}{XR{1.1cm}R{1.1cm}R{1.1cm}R{1.1cm}R{1.1cm}}\hline
 		$k_{max}$		& $+\infty$	& 50		& 20		& 10		& 6 		\\\hline
 		polbooks		& 5.029		& 4.976		& 4.615		& 4.207		& 4.087		\\
 		adjnoun			& 6.115		& 6.099		& 5.481		& 4.952		& 4.744		\\
 		football		& 7.179		& 7.155		& 6.377		& 5.820		& 5.584		\\
 		jazz			& 23.66		& 23.25		& 20.92		& 19.12		& 18.59		\\
 		celegans		& 23.85		& 23.49		& 22.48		& 20.92		& 20.01		\\
 		email			& 70.06		& 72.89		& 68.34		& 63.85		& 62.97		\\
 		netscience		& 477.97	& 85.40		& 46.08		& 38.26		& 30.89		\\
 		cond-mat-2003	& 41,950	& 9,596		& 6,075		& 5,092		& 4,166		\\\hline
 	\end{tabularx}
 	}
\end{table}

Уменьшение максимальной оценки $k_{max}$ играет роль снижения времени работы, более того, часто при уменьшении $k_{max}$ модулярность растет. Сравнение модулярности разбиений и времени работы \emph{ACGGC} с разными значениями $k_{max}$ можно увидеть на таблицах \ref{tab:acggc_kmax_q} и \ref{tab:acggc_kmax_t}.


\subsubsection*{Сравнение CGGC и ACGGC}

Для сравнения \emph{CGGC} и \emph{ACGGC} сопоставлялась медианная модулярность разбиений тестовых графов. На таблице \ref{tab:comparison_cggc_acggc_q} обозначены результаты пять алгоритмов:
\begin{itemize}
	\item $ACGGC$ с параметрами $d = 2,\;\alpha = 1000,\;l = 6,\;\hat{k}_0 = 5,\;k_{max} = 50,\;r = 0.05$, финальным алгоритмом $RG_{10}$, обозначается $ACGGC^I$
	\item $ACGGC$ с параметрами $d = 2,\;\alpha = 1000,\;l = 8,\;\hat{k}_0 = 5,\;k_{max} = 20,\;r = 0.05$, финальным алгоритмом $RG_{10}$, обозначается $ACGGC^{II}$
	\item $CGGC$ с начальным алгоритмом $RG_{10}$, финальным алгоритмом $RG_{10}$ и $s = 16$, обозначается $CGGC_{10}^{10}$
	\item $CGGC$ с начальным алгоритмом $RG_{3}$, финальным алгоритмом $RG_{10}$ и $s = 16$, обозначается $CGGC_{3}^{10}$
	\item $CGGC$ с начальным алгоритмом $RG_{10}$, финальным алгоритмом $RG_{3}$ и $s = 16$, обозначается $CGGC_{10}^{3}$
\end{itemize}

\begin{table}[h!]
	\caption{Модулярность разбиений, полученных \emph{ACGGC} и \emph{CGGC} на тестовых графах}
	\label{tab:comparison_cggc_acggc_q}
	{\footnotesize
	\begin{tabularx}{\textwidth}{Xrrrrr} \hline
				& $ACGGC^{I}$ & $ACGGC^{II}$ & $CGGC_{10}^{10}$	& $CGGC_{3}^{10}$ & $CGGC_{10}^{3}$ \\ \hline
	karate 			& \dotuline{0.417242} 	& \uline{0.417406} 	& 0.415598 	& 0.396532	& 0.405243	\\
	dolphins		& \uline{0.524109}	& \dotuline{0.523338}	& 0.521399	& 0.523338	& 0.522428	\\
	chesapeake		& \dotuline{0.262439}	& \dotuline{0.262439}	& \dotuline{0.262439}	& \dotuline{0.262439}	& 0.262370	\\
	adjnoun			& \uline{0.299704}	& \dotuline{0.299197}	& 0.295015	& 0.292703	& 0.290638	\\
	polbooks		& \dotuline{0.527237}	& \dotuline{0.527237}	& \dotuline{0.527237}	& 0.526938	& 0.526784	\\
	football		& 0.603324	& \dotuline{0.604266}	& \dotuline{0.604266}	& 0.599537	& 0.599026	\\
	celegans 		& \uline{0.439604}	& \dotuline{0.438584} 	& 0.435819	& 0.436066	& 0.432261	\\
	jazz			& 0.444739	& \dotuline{0.444848}	& \uline{0.444871} 	& 0.444206 	& 0.444206	\\
	netscience		& \uline{0.907229}	& \dotuline{0.835267}	& 0.724015 	& 0.708812 	& 0.331957	\\
	email			& \dotuline{0.573333}	& \uline{0.573409}	& 0.571018 	& 0.572667 	& 0.567423	\\
	polblogs		& \uline{0.424107} 	& \dotuline{0.423208}	& 0.422901 	& 0.421361 	& 0.390395	\\
	pgpGiantCompo	& \uline{0.883115} 	& \dotuline{0.883085}	& 0.882237 	& 0.882532	& 0.880340	\\
	as-22july06		& \uline{0.671249}	& \dotuline{0.670677}	& 0.666766	& 0.669847	& 0.665260	\\
	cond-mat-2003	& 0.744533 	& \dotuline{0.750367}	& \uline{0.751109} 	& 0.708775	& 0.413719	\\
	caidaRouterLevel& 0.846312	& \dotuline{0.855651}	& 0.851622 	& \uline{0.858955} 	& 0.843835	\\
	cnr-2000		& 0.912762 	& \uline{0.912783}	& 0.912500 	& \dotuline{0.912777}	& 0.912496	\\
	eu-2005			& \uline{0.938292}  & \dotuline{0.936984}	& 0.935510 	& 0.936515	& 0.936420	\\
	in-2004			& \dotuline{0.979844}	& 0.979771	& \uline{0.979883}	& 			& 			\\
	\hline
	\end{tabularx}
	}
\end{table}

Измерения для $CGGC_3^{10}$ и $CGGC_{10}^3$ на графе \emph{in-2004} не производились из-за большого времени работы.

В таблице \ref{tab:comparison_cggc_acggc_q} лучшая модулярность на графе обозначалась сплошным подчеркиванием, а вторая по величине --- пунктирным подчеркиванием (если несколько алгоритмов принимали лучшее значение --- все отмечались пукнтирной линией и второе по величине значение никак не отмечалось).

При этом $ACGGC$ в основном дают меньшее время, чем $CGGC$ с указанными параметрами, однако в качестве параметра $s$ алгоритма \emph{CGGC} было выбрано значение $s = 16$, так как в \cite{Ovelgoenne&Geyer-Schulz:2012b} отмечалось, что при росте $s$ модулярности приближаются к асимптоте максимального принимаемого алгоритмом значения или держатся на одном уровне. Такое значение будет гарантировать хорошие для \emph{CGGC} модулярности, но не будет гарантировать небольшого времени работы.

\subsubsection*{Итеративная схема}

По аналогии с итеративной схемой \emph{CGGCi} представляется адаптивная итеративная схема \emph{ACGGCi}. В такой схеме после создания промежуточного разбиения --- на его основе вновь выделяют сообщества начальные алгоритмы, это повторяется, пока модулярность промежуточного разбиения увеличивается. И после этого получившееся на основе промежуточного разбиения выделяет сообщества финальный алгоритм. Такой подход не сильно повышает время работы, так как с каждой итерации количество узлов (сообществ) для разбиения уменьшается, и соответственно, выделение сообществ на каждой итерации занимает меньше времени.

\begin{table}[h!]
  	\caption{Модулярность и время работы $ACGGC$ и $ACGGCi$ на пяти графах}
	\label{tab:acggci}%	\footnotesize
	\begin{tabularx}{\columnwidth}{Xrrrr}\hline
						& \multicolumn{2}{c}{$ACGGC$}	& \multicolumn{2}{c}{$ACGGCi$} \\
						& \multicolumn{1}{c}{$Q$}	& \multicolumn{1}{c}{$t$} & \multicolumn{1}{c}{$Q$}	& \multicolumn{1}{c}{$t$} \\\hline
		jazz 			& 0.444739	& 23.68		& 0.444871	& 31.51		\\
		celegans 		& 0.439724	& 23.92		& 0.446973	& 77.25		\\
		netscience 		& 0.907922	& 86.38		& 0.909400	& 96.55		\\
		as-22july06		& 0.671205	& 2,329		& 0.674992	& 5,801		\\
		cond-mat-2003	& 0.743594	& 9,371		& 0.746731	& 11,654	\\
		\hline
	\end{tabularx}
\end{table}

Как видно из таблицы \ref{tab:acggci}, модулярность итеративной схемы каждый раз немного выше, хотя и время работы каждый раз заметно выростало, на некоторых графах в полтора раза, а на других --- более, чем в три.

В качестве финального алгоритма \emph{ACGGCi} можно использовать \emph{CGGCi}, ровно как и наоборот, в качестве финального алгоритма \emph{CGGCi} использовать \emph{ACGGCi}. Такой подход обусловлен тем, что не умоляя общности сначала \emph{ACGGCi} итерирует создание промежуточных разбиений, останавливаясь, когда это перестает приносить выигрыш. Однако другая схема может оказаться эффективной на получившемся промежуточном разбиении. Назовем такой подход \emph{комбинированной схемой кластеризации}.

На графе \emph{celegans} провелось сравнение модулярности и времени работы итерационных схем с разными финальными алгоритмами, результаты изображены на таблице \ref{tab:cggci_as_final}. Стрелка $\rightarrow$ указывает на то, какой алгоритм принимает начинает следующим выделять сообщества в промежуточном множестве. Например, $ACGGCi \rightarrow CGGCi \rightarrow RG_{10}$ обозначает $ACGGCi$ с финальным алгоритмом $CGGCi$ с финальным алгоритмом $RG_{10}$. Начальным алгоритмом $CGGCi$ используется также $RG_{10}$.

\begin{table}[h!]
	\caption{Модулярность и время работы итерационных схем с разными финальными алгоритмами}
	\label{tab:cggci_as_final}
	\centering
	\begin{tabularx}{\textwidth}{llXrr}\hline
		& & & \multicolumn{1}{c}{$Q$}	& \multicolumn{1}{c}{$t$} \\\hline
	$ACGGCi$ & $\rightarrow RG_{10}$ &					& 0.446973	& 77.25 	\\
	$CGGCi$ & $\rightarrow RG_{10}$ &					& 0.445008	& 55.29 	\\
	$ACGGCi$ & $\rightarrow CGGCi$ & $\rightarrow RG_{10}$ 	& 0.447324	& 89.96		\\
	$CGGCi$ & $\rightarrow ACGGCi$ & $\rightarrow RG_{10}$ 	& 0.445660	& 112.49	\\\hline
	\end{tabularx}
\end{table}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{prodanov/prodanov_cggci_as_final.eps}
	\caption{Модулярность промежуточных разбиений в работе $ACGGCi \rightarrow CGGCi \rightarrow RG_{10}$ на графе \emph{celegans}, $i$ --- номер итерации. Круглые точки указывают промежуточные разбиения $ACGGCi$, а квадратные --- $CGGCi$}
	\label{fig:cggci_as_final}
\end{figure}

На графе \emph{celegans} комбинированные схемы с $CGGCi$ и $ACGGCi$ на первом этапе дали лучшие результаты, чем обычные итерационные схемы $CGGCi$ и $ACGGCi$, соответственно.

\subsubsection*{Сравнение итерационных схем}

\begin{table}[h!]
	\caption{Модулярность работы четырех итеративных алгоритмов на небольших тестовых графах}
	\label{tab:iterative_results}
	% \footnotesize
	\begin{tabularx}{\textwidth}{Xrrrr} \hline
					& $ACGGCi^{I}$ & $ACGGCi^{II}$ & $CGGCi$	& combined \\ \hline
	karate			& 0.417242	& \uline{0.417406}	& 0.417242	& 0.417242	\\
	dolphins		& 0.525869	& 0.525869	& 0.525869	& 0.525869	\\
	chesapeake		& 0.262439	& 0.262439	& 0.262439	& 0.262439	\\
	adjnoun			& 0.303731	& 0.303504	& 0.303571	& \uline{0.303970}	\\
	polbooks		& 0.527237	& 0.527237	& 0.527237	& 0.527237	\\
	football		& 0.604266	& 0.604407	& \uline{0.604429}	& 0.604407	\\
	celegans 		& 0.446964	& 0.446836	& 0.445442	& \uline{0.447234}	\\
	jazz			& 0.444871	& 0.444871	& 0.444871	& 0.444871	\\
	netscience		& \uline{0.908845}	& 0.888422	& 0.725781	& 0.907443	\\
	email			& 0.576778	& 0.577000	& 0.576749	& \uline{0.577110}	\\
	polblogs		& \uline{0.424025}	& 0.422920	& 0.423281	& 0.423996	\\
	\hline
	\end{tabularx}
\end{table}

На таблице \ref{tab:iterative_results} представлено сравнение модулярностей четырех алгоритмов, $ACGGCi^{I}$, $ACGGCi^{II}$ и $CGGCi$ представляют итеративные версии $ACGGC^{I}$, $ACGGC^{II}$ и $CGGC_{10}^{10}$, соответственно. Схема $ACGGCi \rightarrow CGGCi \rightarrow RG_{10}$ изображена в таблице под названием \emph{combined}. Сплошной линией отмечены лучшие разбиения.

Итеративная схема $CGGCi$ на тестовых графах всего единожды приняла лучшее значение, и, в отличии от остальных итерационных схем, один раз (на графе \emph{netscience}) приняла очень плохое значение.